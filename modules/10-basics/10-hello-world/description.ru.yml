---

name: Привет, Мир!
theory: |

  Racket - мультипарадигменный язык общего назначения, входящий в Lisp-семейство. Подчеркну, что Lisp - это не название конкретного языка, а обозначение группы языков, обладающих определенными схожими свойствами. Racket, как и большинство других лиспоподобных языков, не является функциональным языком программирования. На нем можно писать как функционально, так и императивно.

  Lisp-языков много, а первый появился в 1958 году. Его автором был Джон Маккарти - автор термина «искусственный интеллект», основоположник функционального программирования, лауреат премии Тьюринга за огромный вклад в область исследований искусственного интеллекта.

  Кроме Racket, в современной разработке относительно популярны - Clojure, ClojureScript, Common Lisp и Scheme (читается "ским"). Интересный факт: редактор Emacs написан на собственном диалекте, который называется Emacs Lisp. И все программисты, использующие emacs, в какой-то степени являются Lisp-программистами.

  Все что дальше будет говориться про Racket, почти всегда справедливо и для остальных Lisp-языков. Racket и Scheme в своей основе выглядят идентично. Этим фактом можно пользоваться при работе в https://repl.it, где нет Racket, но есть Scheme.

  По традиции начнём знакомство с языком с написания программы "Hello, World!". Эта программа будет выводить на экран текст _Hello, World!_. Для вывода на экран в Racket используется функция `displayln`:

  ```scheme
  #lang racket

  (displayln "Hello, World!")
  ```

  В Lisp языках традиционно говорят "процедура", а не функция. Исторически, процедура это блок кода, который не имеет возврата и как правило нужен для выполнения побочных эффектов. А под функцией понимают функцию в ее математическом значении. Функция зависит от своих аргументов и вычисляет результат, который затем возвращается наружу. В некоторых языках, таких как Pascal, эти понятия разнесены на уровне синтаксиса и семантики. В большинстве же языков функциями называют в том числе процедуры. В документации Racket встречается и то и другое. Для простоты мы будем всегда говорить о функциях.

  В примере выше есть строчка `#lang racket`, она называется прагма. Прагма нужна для определения "ридера", механизма, который читает исходный файл и парсит его. В Lisp языках ридер можно подменять, что открывает широкие возможности по модификации синтаксиса языка. Racket поставляется со множеством готовых ридеров, например [Typed Racket](https://docs.racket-lang.org/ts-guide/). Фактически этот ридер определяет новый язык программирования.

  Racket требует установки прагмы в каждый файл с исходным кодом (есть исключение но это сейчас не важно), но в нашей среде он присутствует не всегда (по техническим причинам). Не забудьте про эту разницу, когда решите запускать Racket программы у себя на компьютере.


instructions: |
  Наберите в редакторе код из задания символ в символ и нажмите «Проверить».

  ```scheme
  ; я комментарий
  (displayln "Hello, World!")
  ```

tips:
  - |
    [repl.it](https://repl.it/languages/scheme) - здесь вы можете экспериментировать с кодом на Racket.
  - |
    Используйте [готовый бойлерплейт](https://github.com/hexlet-boilerplates/sicp-racket) для прохождения SICP на Racket
  - |
    Посмотрите доклад [Simple Made Easy](https://www.infoq.com/presentations/Simple-Made-Easy)
