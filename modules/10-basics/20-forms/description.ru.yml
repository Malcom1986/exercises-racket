---

name: Формы
theory: |

  Про Lisp языки говорят что у этих языков нет синтаксиса. Синтаксис у них конечно есть, но максимально примитивный, фактически состоящий из списков и значений. Кроме того, в Lisp языках отсутствуют ключевые слова и соответствующие им конструкции. В обычных языках существует множество управляющих конструкций, таких как условия, циклы, возврат, присвоение переменных и многое другое. В Lisp языках таких конструкций нет. Это не значит что на Racket нельзя реализовать цикл или написат условие. Можно.

  Тогда каким образом Racket понимает с чем сейчас он работает и что нужно делать? Все дело в формах. Любая корректная программа на Lisp называется формой. Например:

  ```scheme
  ; форма
  (display "i am from form")
  ; форма
  (+ 1 2)
  ; и это формы
  8
  "hello"

  ; а это не форма, так как такой код завершится с ошибкой
  (1 2 3)
  ```

  Форм всего две - нормальная и составная. Нормальной соответствуют все значения (и определения, с которыми мы познакомимся позже), так как они вычисляются сами в себя, например, число _8_ или строка "hello". Составная форма это список, способ вычисления которой, зависит от выполняемого действия.

  Когда код представлен как список, появляется простор для интерпретации. Возьмем сложение двух чисел, например, 3 и 2. В виде списка такое сложение можно представить тремя разными способами:

  * `(3 + 2)`
  * `(3 2 +)`
  * `(+ 3 2)`

  В Lisp языках используется префиксная нотация, то есть первый элемент формы определяет поведение (семантику). Такой способ обладает рядом преимуществ. Например он позволяет естественным образом выполнять действие с любым набором элементов:

  ```scheme
  ; 3 + 2 + 8 + 3 + 9
  (+ 3 2 8 3 9) ; 25

  ; 3 - 2 - 8 - 3 - 9
  (- 3 2 8 3 9) ; -19
  ```

  Другое преимущество - значительно проще реализовать динамическую диспетчеризацию по сравнению с другими языками. Этому способствуют и макросы.

instructions: |

  Выведите на экран значение выражения _10 - 100 - 12 - 18_

definitions: []
tips: []
