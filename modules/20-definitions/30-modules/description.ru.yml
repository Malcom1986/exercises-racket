---

name: Модули
theory: |

  Система модулей в Racket похожа на подобные системы в других языках. Каждый файл, обычно, содержит ровно один модуль:

  ```scheme
  ; math.rkt
  #lang racket

  (define (sum a b) (+ a b))
  ```

  По умолчанию, все идентификаторы определенные внутри модуля, остаются внутри модуля. Если другой модуль выполнит импорт `import "math.rkt"`, то он не сможет воспользоваться содержимым импортируемого модуля. Для экспорта определений используется конструкция `provide`:

  ```scheme
  ; math.rkt
  #lang racket

  (provide sum)

  (define (sum a b) (+ a b))
  ```

  В `provide` перечисляются имена переменных, которые нужно экспортировать. Любой другой модуль автоматически получает к ним доступ после импорта:

  ```scheme
  #lang racket

  (require "math.rkt")

  (define result (sum 5 3))
  ```

  Обратите внимание на следующие детали:

  * `require` работает с путями, ему можно передать как абсолютный так и относительный путь. В примере выше предполагается что оба модуля лежат в одной директории.
  * `require` автоматически делает доступным все что он импортировал из другого модуля.

  В некоторых ситуациях удобно использовать форму `(provide (all-defined-out))`. Она указывает на необходимость экспорта всех переменных, определенных в модуле.

  А вот с импортом наоборот, не всегда удобно импортировать сразу все. Во-первых возможны конфликты имен, во-вторых хочется явно понимать что откуда берется. В таких ситуациях используется особая форма `require`:

  ```scheme
  (require (only-in "math.rkt" sum))
  ```

  `only-in` говорит что надо включить из модуля `"math.rkt"` переменную `sum` и больше ничего. Для включения дополнительных переменных, достаточно добавить их имена в конец списка.

instructions: |

  Экспортируйте переменную определенную в коде

definitions:
  - name: Объект первого рода
    description: Сущность в языке, которая рассматривается как данные. Это значит что ее можно записывать в переменную, передавать в функции и возвращать из функций.
tips: []
