---

name: Модули
theory: |

  Система модулей в Racket похожа на подобные системы в других языках. Каждый файл, обычно, содержит ровно один модуль:

  ```scheme
  ; math.rkt
  #lang racket

  (define (sum a b) (+ a b))
  ```

  По умолчанию, все определения сделанные в модуле, остаются внутри модуля. Если другой модуль выполнит импорт `import "math.rkt"`, то он не сможет воспользоваться содержимым импортируемого модуля. Сначала их нужно экспортировать. Для экспорта определений используется форма `provide`:

  ```scheme
  ; math.rkt
  #lang racket

  (provide sum)

  (define (sum a b) (+ a b))
  ```

  В `provide` перечисляются имена определений, которые нужно экспортировать. Любой другой модуль автоматически получает к ним доступ после импорта:

  ```scheme
  #lang racket

  (require "math.rkt")

  (define result (sum 5 3))
  ```

  Обратите внимание на следующие детали:

  * `require` работает с путями, ему можно передать как абсолютный так и относительный путь. В примере выше предполагается что оба модуля лежат в одной директории.
  * `require` автоматически делает доступным все что он импортировал из другого модуля.

  В некоторых ситуациях удобно использовать форму `(provide (all-defined-out))`. Она указывает на необходимость экспорта всех определений модуля.

  А вот с импортом наоборот, не всегда удобно импортировать сразу все. Во-первых возможны конфликты имен, во-вторых хочется явно понимать что откуда берется. В таких ситуациях используется особая форма `require`:

  ```scheme
  (require (only-in "math.rkt" sum))
  ```

  `only-in` говорит что надо включить из модуля `"math.rkt"` переменную `sum` и больше ничего. Для включения дополнительных определений, достаточно добавить их имена в конец списка.

instructions: |

  Экспортируйте определение, которое есть в загруженном модуле

definitions: []
tips: []
