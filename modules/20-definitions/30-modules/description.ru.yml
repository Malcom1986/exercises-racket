---

name: Модули
theory: |

  В Racket любая функция это лямбда-функция. Это означает две вещи:

  * У функций нет имени. Говорят что функция анонимная.
  * Функции являются объектами первого рода. То есть их можно присваивать переменным, передавать как аргументы функций и возвращать из функций.

  Примеры:

  ```scheme
  ; определение функции вычисляющую сумму двух чисел
  (lambda (x y) (+ x y))
  ```

  В примере выше создается функция, за это отвечает `lambda`. Вторым элементом в форме создания функции идут аргументы. Аргументы передаются так же списком. Третий элемент - тело функции. По традиции тоже список.

  Обратите внимание на отсутствие инструкции `return`. В отличие от большинства других языков, в Lisp языках инструкций не существует. Все есть выражение. А выражения всегда возвращают результат. Если хорошо подумать, то такое поведение следует из самой структуры Lisp программы. Фактически мы имеем дерево, которое должно вычислиться в какое-то значение, значит на каждом уровне должен создаваться возврат, поднимающийся выше по дереву и так до самого корня. Возвращается всегда последнее вычисленное выражение.

  Пара примеров для закрепления:

  ```scheme
  ; печать на экран
  (lambda () (display "hello!"))
  ; квадрат числа
  (lambda (n) (* n n))

  ; среднее между двумя числами
  (lambda (num1 num2) (/ (num1 + num2) 2))
  ```

  Раз функция объект первого рода, то мы можем создать переменную и присвоить ей функцию:

  ```scheme
  (define square (lambda (n) (* n n)))
  ```

  Теперь попробуем вызвать:

  ```scheme
  (square 7) ; 49
  (square 5) ; 25
  ```

instructions: |

  Создайте функцию с именем `cube`, которая вычисляет куб переданного числа

definitions:
  - name: Объект первого рода
    description: Сущность в языке, которая рассматривается как данные. Это значит что ее можно записывать в переменную, передавать в функции и возвращать из функций.
tips: []
