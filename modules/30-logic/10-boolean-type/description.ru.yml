---

name: Логические операторы
theory: |

  True и False в Racket представлены значениями `#t` и `#f`. Запись непривычная, но в языках созданных много лет назад встречается и не такое. Большинство операций в Racket рассматривают как ложь только `#f`. Все остальное считается истиной. Пара примеров на сравнение:

  ```scheme
  (= "cat" "cat") ; #t
  (= "cat" "dog") ; #f
  ```

  Знак равно не означает присваивания, это именно сравнение.

  Напишем функцию, `gt`, которая возвращает `#t` если первое число больше второго и `#f` в другом случае. В Racket, предикаты оканчиваются на вопросительный знак. При этом к ним не добавлется префикс _is_.

  ```scheme
  (define (gt? x y) (> x y))
  (gt? 3 2) ; #t
  (gt? 10 15) ; #f
  ```

  _Вот так руби разработчики узнали почему в руби предикаты выглядят как вопросы :)_

  Теперь напишем предикат определяющий четность числа. Для этого нам понадобится функция `remainder`, которая находит остаток от деления.

  ```scheme
  (define (even? n) (= (remainder n 2) 0))
  (even? 3) ; #f
  (even? 4) ; #t
  ```

  Логические операторы в Racket не имеют символьных обозначений, как в других языках, вместо этого используются функции `and`, `or`, `not` и другие.

  ```scheme
  (not "moon") ; #f
  (and (odd? 3) (even? 4)) ; #t
  ```

instructions: |

  Напишите функцию `same-parity?`, которая принимает на вход два числа и возвращает `#t` в том случае если их четность совпадает. В ином случае возвращается `#f`.

  ```scheme
  (same-parity? 3 7) ; #t
  (same-parity? 4 8) ; #t
  (same-parity? 4 7) ; #f
  (same-parity? 3 10) ; #f
  ```

tips: []
